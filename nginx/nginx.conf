worker_processes 1; # Adjust based on CPU cores, auto is often fine

events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;
    error_log   /var/log/nginx/error.log   warn;

    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    keepalive_timeout  65;
    types_hash_max_size 2048;
    # server_tokens off; # Hide Nginx version

    # gzip on;
    # gzip_disable "msie6";
    # gzip_vary on;
    # gzip_proxied any;
    # gzip_comp_level 6;
    # gzip_buffers 16 8k;
    # gzip_http_version 1.1;
    # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss image/svg+xml;

    # Define upstreams for our services
    # These names match the service names in docker-compose.yml
    upstream backend_service {
        server backend:8000; # 'backend' is the service name, 8000 is its internal port
    }

    upstream ai_agent_service {
        server ai_agent:8001; # 'ai_agent' is the service name, 8001 is its internal port
    }

    upstream frontend_service_dev {
        # For local development, frontend runs on react-scripts dev server (port 3000)
        server frontend:3000; # 'frontend' is the service name, 3000 is its internal port
    }
    # For production, frontend will be static files served by its own Nginx on port 80
    # This would be used in a separate nginx.prod.conf or by adjusting this with env vars
    # upstream frontend_service_prod {
    #     server frontend:80;
    # }


    server {
        listen 80;
        server_name localhost; # Replace with your domain in production

        # Optional: Basic Security Headers (can be expanded)
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        # add_header X-Frame-Options "SAMEORIGIN" always; # Uncomment if needed
        # add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always; # Example, needs careful tuning

        # API endpoint for Backend
        location /api/v1/backend/ {
            proxy_pass http://backend_service/; # Note the trailing slash
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # To handle path rewriting correctly if /api/v1/backend/ should map to / of backend service
            # rewrite ^/api/v1/backend/(.*)$ /$1 break; # If backend expects paths from its root
            # If backend FastAPI app is designed to handle /api/v1/backend/ prefix itself, then no rewrite needed.
            # Assuming backend's FastAPI routes are like @app.get("/users/me") not @app.get("/api/v1/backend/users/me")
            # So, a rewrite or careful proxy_pass is needed.
            # If proxy_pass has a URI (like / in http://backend_service/), then the part of
            # the normalized request URI that matches the location is replaced by the URI in proxy_pass.
            # Example: /api/v1/backend/users/me -> /users/me on backend_service
            # This is usually the desired behavior.
        }

        # API endpoint for AI Agent
        location /api/v1/agent/ {
            proxy_pass http://ai_agent_service/; # Trailing slash is important
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            # Similar rewrite logic as above if needed
            # rewrite ^/api/v1/agent/(.*)$ /$1 break;
        }

        # Frontend (React App)
        # For local development, this proxies to the React dev server
        location / {
            proxy_pass http://frontend_service_dev; # Proxy to React dev server
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            # For WebSocket connections used by React dev server (hot reloading)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # Optional: Deny access to .env, .git files if they were somehow exposed
        location ~ /\. {
            deny all;
        }
    }

    # If SSL is configured (e.g., for production):
    # server {
    #    listen 443 ssl http2;
    #    server_name yourdomain.com;
    #
    #    ssl_certificate /etc/nginx/ssl/live/yourdomain.com/fullchain.pem;
    #    ssl_certificate_key /etc/nginx/ssl/live/yourdomain.com/privkey.pem;
    #    include /etc/nginx/ssl/options-ssl-nginx.conf; # SSL hardening options
    #    ssl_dhparam /etc/nginx/ssl/ssl-dhparams.pem; # Diffie-Hellman params
    #
    #    # ... same location blocks as above, or include them from a common file ...
    #
    #    # Redirect HTTP to HTTPS
    #    if ($scheme != "https") {
    #        return 301 https://$host$request_uri;
    #    }
    # }
}
